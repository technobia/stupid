import {SequelizeRepositoryBase} from "infrastructure/Repository";
import {ObjectAlreadyExistsException, ObjectNotFoundException} from "domain/Exception";
import assert from "framework/Assert";
import {UUID} from "domain/UUID";

import {Entity, EntityDTO} from "domain/Entity";
import sequelize = require("sequelize");
import {Instance} from "sequelize";
import {literal} from "sequelize";
import {col} from "sequelize";

export interface CrudDao<T extends Entity<ActiveRecord, EntityDTO>, ActiveRecord extends Instance<DbRow>, DbRow> {
    create(object: T): T;
    createAll(objects: T[]): T[];
    findAllByIds(uuid: UUID[], order: OrderType<sequelize.Model<ActiveRecord, DbRow>>): T[];
    findById(uuid: UUID): T;
    update(object: T): void;
    updateAll(objects: T[]): void;
    delete(uuid: UUID): void;
    deleteAll(uuid: UUID[]): void;
}

type OrderTypeTuple<Model> = string |
    col |
    literal |
    Array<
        string |
            number |
            Model |
            { model: Model, as?: string }
        >;

type OrderType<Model> = OrderTypeTuple<Model> | Array<OrderTypeTuple<Model>>;

export function MakeCrudDao<T extends Entity<ActiveRecord, EntityDTO>, ActiveRecord extends Instance<DbRow>, DbRow>(
    schema: sequelize.Model<ActiveRecord, DbRow>,
    fromActiveRecord: (record: ActiveRecord) => T
): CrudDao<T, ActiveRecord, DbRow> {
    return new CrudDaoImpl<T, ActiveRecord, DbRow>(schema, fromActiveRecord);
}

export class CrudDaoImpl<T extends Entity<ActiveRecord, EntityDTO>, ActiveRecord extends Instance<DbRow>, DbRow>
extends SequelizeRepositoryBase<ActiveRecord, DbRow>
implements CrudDao<T, ActiveRecord, DbRow> {

    private fromActiveRecord: (record: ActiveRecord) => T;

    public constructor(
        schema: sequelize.Model<ActiveRecord, DbRow>,
        fromActiveRecord: (record: ActiveRecord) => T
    ) {
        super(schema);
        this.fromActiveRecord = fromActiveRecord;
    }

    public create(object: T): T {
        const uuid = object.getId();
        assert(this._findByIdNoThrow(uuid) === null, ObjectAlreadyExistsException, uuid);
        this.wait(object.record.save());
        return object;
    }

    // @TODO optimize this
    public createAll(objects: T[]): T[] {
        return objects.map((object: T) => this.create(object));
    }

    public findAllByIds(ids: UUID[], order: OrderType<sequelize.Model<ActiveRecord, DbRow>>): T[] {
        const result = this.wait(this.schema.findAll({where: {uuid: this._uuidsToString(ids)}, order}));
        assert(result.length === ids.length,
            `looked for ${ids.length} but found ${result.length}`, ObjectNotFoundException, ids);
        return result.map((record: ActiveRecord) => this.fromActiveRecord(record));
    }

    public findById(uuid: UUID): T {
        const record = this._findByIdNoThrow(uuid);
        assert(!!record, ObjectNotFoundException, "uuid: " + uuid);
        return this.fromActiveRecord(record);
    }

    public update(object: T): void {
        const dto = object.record.toJSON();
        const uuid = object.getId();
        const updatedCount = +this.wait(this.schema.update(dto, {where: {uuid: uuid.value}}));
        assert(updatedCount === 1, `updated ${updatedCount} from 1`);
    }

    // @TODO optimize this
    public updateAll(objects: T[]): void {
        objects.forEach((object: T) => this.update(object));
    }

    public delete(uuid: UUID): void {
        this.deleteAll([uuid]);
    }

    public deleteAll(ids: UUID[]): void {
        const deletedCount = this.wait(this.schema.destroy({where: {uuid: this._uuidsToString(ids)}}));
        assert(deletedCount === ids.length, `updated ${deletedCount}, from ${ids.length}`);
    }

    private _findByIdNoThrow(uuid: UUID): ActiveRecord {
        return this.wait(this.schema.findOne({where: {uuid: uuid.value}}));
    }

    private _uuidsToString(ids: UUID[]): string[] {
        return ids.map((id: UUID) => id.value);
    }

}
