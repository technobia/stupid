const _parser = require("csv-parser");
const _fs = require("fs");
import WaitForPromise from "infrastructure/WaitForPromise";
const waitFor = require("wait.for");
const _readline = require("readline");

const DEFAULT_CHUNK_SIZE = 1;

export interface CSVReader {
    read(link: string, chunkHandler: (chunk: any) => void, columns: string[]): void;
}

export function MakeCSVReader(chunkSize?: number, parser?: any, fs?: any, wait?: any, fiber?: any, readline?: any) {
    return new CSVReaderImpl(
        chunkSize || DEFAULT_CHUNK_SIZE,
        parser || _parser,
        fs || _fs,
        wait || WaitForPromise,
        fiber || ((fn: any) => waitFor.launchFiber(fn)),
        readline || _readline
    );
}

class CSVReaderImpl implements CSVReader {

    private parser: any;
    private fs: any;
    private chunkSize: number;
    private fiber: any;
    private wait: any;
    private readline: any;

    constructor(chunkSize: number, parser: any, fs: any, wait: any, fiber: any, readline: any) {
        this.chunkSize = chunkSize;
        this.parser = parser;
        this.fs = fs;
        this.wait = wait;
        this.fiber = fiber;
        this.readline = readline;
    }

    public read(link: string, chunkHandler: (chunk: any) => void, columns: string[]): void {
        const self = this;
        const lastCsvData = this.wait(new Promise((resolve: any, reject: any) => {
            let csvData: any[] = [];
            let csvFailedData: any[] = [];
            try {
                const stream = this.readline.createInterface({
                    input: this.fs.createReadStream(link),
                });
                let promises: Promise<any>[] = [];
                let lastLine: string;
                stream
                    .on("line", (line: any) => {
                        stream.pause();
                        if (lastLine !== undefined) {
                            line = lastLine + line;
                            lastLine = undefined;
                        }

                        const parsed = parseLine(line);
                        if (parsed.isWaitingForEndOfField) {
                            lastLine = line;
                            stream.resume();
                        } else {
                            const row = decorate(parsed.fields, columns);
                            row ? csvData.push(row) : csvFailedData.push(line);
                            if (csvData.length >= self.chunkSize) {
                                promises.push(new Promise((resolveFiber: any) => {
                                    this.fiber(() => {
                                        const data = { csvData, csvFailedData };
                                        csvData = [];
                                        csvFailedData = [];
                                        chunkHandler(data);
                                        stream.resume();
                                        resolveFiber();
                                    });
                                }));
                            } else {
                                stream.resume();
                            }
                        }
                    })
                    .on("close", () => {
                        Promise.all(promises).then(() => resolve({ csvData, csvFailedData }));
                    })
                    .on("error", (err: any) => {
                        reject(err);
                    });
            } catch (e) {
                console.error(e);
                reject(e);
            }
        }));
        if (lastCsvData.csvData.length > 0) {
            chunkHandler(lastCsvData);
        }
    }
}

export function parseLine(line: string) {
    let currentField = "", fields: string[] = [], isWaitingForEndOfField = false;
    for (let i = 0; i < line.length; i++) {
        switch (line[i]) {
            case ",":
                if (!isWaitingForEndOfField) {
                    fields.push(currentField);
                    currentField = "";
                    break;
                }
                currentField += line[i];
                break;
            case `"`:
                if (line[i + 1] === `"` || line[i - 1] === `"`) {
                    currentField += line[i];
                }
                isWaitingForEndOfField = !isWaitingForEndOfField;
                break;
            default:
                currentField += line[i];
                break;
        }
    }
    if (line[line.length - 1] === ",") { fields.push(""); }
    return { isWaitingForEndOfField, fields };
}

function decorate(fields: string[], columns: string[]) {
    try {
        let row: any = {};
        columns.forEach((c: string, index: number) => {
            row[c] = fields[index] || "";
        });
        return row;
    } catch (e) {
        console.log(e);
        return false;
    }
}
