/**
 * Created by jose on 29/09/2015.
 */

const winston = require("winston");
import WaitForPromise from "infrastructure/WaitForPromise";
import Transactional from "infrastructure/Transactional";
import SQLScriptRunner from "infrastructure/SQLScriptRunner";
import FiberPromise from "infrastructure/FiberPromise";
import SequelizeConnection from "infrastructure/SequelizeConnection";
const Sequelize = SequelizeConnection.Sequelize;
const Connection = SequelizeConnection.connection;

export default class MigrationRunner {

    private logger: any;
    private migrations: any;
    private wait: any;
    private fiberPromise: any;
    private t: any;

    constructor(migrations: any, wait: any, logger: any, fiberPromise: any, t: any) {
        this.logger = logger;
        this.migrations = migrations;
        this.wait = wait;
        this.fiberPromise = fiberPromise;
        this.t = t;
    }

    public static make(logger?: any, migrations?: any, wait?: any, fiberPromise?: any, t?: any) {
        return new MigrationRunner(
            migrations || makeUmzug(logger),
            wait || WaitForPromise,
            logger || winston,
            fiberPromise || FiberPromise,
            t || Transactional
        );
    }

    public up(): Promise<void> {
        return this.fiberPromise(() => {
            const migrationsPending = this.wait(this.migrations.pending())
                .map((m: any) => m.file);

            this.logger.info("MIGRATIONS TO EXECUTE: ", migrationsPending);

            this.wait(this.migrations.up().catch( (e: any) => {
                this.handleError(e);
                process.exit(1);
            }));

            this.logger.info("MIGRATIONS DONE");
        });
    }

    public handleError(e: any) {
        this.logger.error(e.name, e.message, e.parent, e.original, e.stack);
    }
}

export class MigrationInterface {

    private queryInterface: any;
    private wait: any;

    constructor(queryInterface: any, wait: any) {
        this.queryInterface = queryInterface;
        this.wait = wait;
    }

    public static make(queryInterface?: any, wait?: any) {
        return new MigrationInterface(queryInterface || Connection.getQueryInterface(), wait || WaitForPromise);
    }

    public addColumn(...args: any[]) {
        return this.wait(this.queryInterface.addColumn(...args));
    }

    public createTable(...args: any[]) {
        return this.wait(this.queryInterface.createTable(...args));
    }

    public changeColumn(...args: any[]) {
        return this.wait(this.queryInterface.changeColumn(...args));
    }

    public removeColumn(...args: any[]) {
        return this.wait(this.queryInterface.removeColumn(...args));
    }

    public bulkInsert(...args: any[]) {
        return this.wait(this.queryInterface.bulkInsert(...args));
    }

    public bulkDelete(...args: any[]) {
        return this.wait(this.queryInterface.bulkDelete(...args));
    }

    public query(...args: any[]) {
        return this.wait(this.queryInterface.sequelize.query(...args));
    }

    public addIndex(...args: any[]) {
        return this.wait(this.queryInterface.addIndex(...args));
    }
}

const Umzug = require("umzug");

export function makeUmzug(logger?: any, fiberPromise?: any, schema?: any, sqlRunner?: any) {
    fiberPromise = fiberPromise || FiberPromise;
    logger = logger || winston;
    schema = schema || MigrationInterface.make();
    sqlRunner = sqlRunner || SQLScriptRunner.make();
    return new Umzug({
        logging: function (message: string) {
            logger.info(message);
        },
        migrations: {
            params: [{schema, Sequelize, sqlRunner}],
            path: "compiled-src/node_modules/migrations",
            pattern: /\.js$/,
            wrap(fn: any) {
                return (...args: any[]) => fiberPromise(() => fn(...args));
            }
        },
        storage: "sequelize",
        storageOptions: {sequelize: Connection},
    });
}
