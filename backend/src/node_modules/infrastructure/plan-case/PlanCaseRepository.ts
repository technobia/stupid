/**
 * Created by x on 30/08/16.
 */
import {SequelizeRepositoryBase} from "infrastructure/Repository";
import {PlanCase, PlanCaseImpl, PlanCaseFromActiveRecord, PlanCaseActiveRecord, PlanCaseDbRow} from "domain/plan-case/PlanCase";
import {UUID} from "domain/UUID";
import {QueryReader} from "infrastructure/QueryReader";
import {PlanCaseReadModel, PlanCaseReadModelActiveRecord, PlanCaseReadModelFromActiveRecord} from "domain/plan-case/PlanCaseReadModel";
import Configuration from "Configuration";
const _knex = require("knex")(Configuration.knexConfig);
const ALLOW_MULTIPLE = Configuration.enableMultipleLookup;


export interface PlanCaseRepository {
    create(instance: PlanCase): PlanCase;
    update(instance: PlanCase): void;
    delete(uuid: UUID): void;
    findOne(uuid: UUID): PlanCase;
    find(queryParam: RawPlanCaseQueryParam): PlanCaseReadModel[];
}

import {CrudDao, MakeCrudDao} from "infrastructure/CrudDao";

export function MakePlanCaseRepository(
    crud?: CrudDao<PlanCase, PlanCaseActiveRecord, PlanCaseDbRow>, knex?: any): PlanCaseRepository {
    return new PlanCaseSequelizeRepository(crud || MakeCrudDao(PlanCaseImpl.SCHEMA, PlanCaseFromActiveRecord), knex || _knex);
}

export class PlanCaseSequelizeRepository extends
    SequelizeRepositoryBase<PlanCaseActiveRecord, PlanCaseDbRow> implements PlanCaseRepository {

    private crud: CrudDao<PlanCase, PlanCaseActiveRecord, PlanCaseDbRow>;
    private knex: any;

    constructor(
        crud: CrudDao<PlanCase, PlanCaseActiveRecord, PlanCaseDbRow>, knex: any) {
        super(PlanCaseImpl.SCHEMA);
        this.crud = crud;
        this.knex = knex;
    }

    public create(instance: PlanCase): PlanCase {
        return this.crud.create(instance);
    }

    public update(instance: PlanCase): void {
        this.crud.update(instance);
    }

    public delete(uuid: UUID): void {
        return this.crud.delete(uuid);
    }

    public findOne(uuid: UUID): PlanCase {
        return this.crud.findById(uuid);
    }

    public find(queryParam: RawPlanCaseQueryParam): PlanCaseReadModel[] {
        const numberOfParticipant = queryParam.persons.length;
        const table = "company_plans";
        let queryBuilder = (ALLOW_MULTIPLE && numberOfParticipant > 1) ?
            this._buildMultipleQuery({ queryParam }, table, this.knex) :
            this._buildQuery({ queryParam }, table, this.knex);

        const queryReader = new QueryReader<PlanCaseReadModelActiveRecord>(queryBuilder);
        return queryReader.query().map((o: PlanCaseReadModelActiveRecord) => PlanCaseReadModelFromActiveRecord(o));
    }

    private _buildMultipleQuery(queryData: CreateBuildQueryData, table: string, knex: any): any {
        const self = this;
        const params = MakePlanCaseQueryParam(queryData.queryParam);
        let columns = this._getColumns();
        columns.forEach(function(column: string) {
            if (column !== "plan_case_id") {
                knex = knex.max(`x.${column} as ${column}`);
            }
        });
        knex = knex.count("x.plan_id as participants")
            .sum("x.annual_premium as total_annual_premium")
            .select(this.knex.raw("group_concat(x.plan_case_id) as plan_case_id"))
            .select()
            .from(function () {
                self._buildSubQuery(params.persons, table, this);
            });
        knex = this._updateCondition(queryData, knex);
        return knex.groupBy("plan_id").having("participants", "=", params.persons.length);
    };

    private _buildSubQuery(persons: Person[], table: string, knex: any) {
        persons.forEach(function (person: Person, index: number) {
            const age = person.age;
            if (index === 0) {
                knex.select().from("company_plans").whereRaw("age_minimum <= ? AND age_maximum >= ?", [age, age]);
            } else {
                knex.unionAll(function () {
                    this.select().from("company_plans").whereRaw("age_minimum <= ? AND age_maximum >= ?", [age, age]);
                });
                if (index === (persons.length - 1)) { knex.as("x"); }
            }
        });
    }

    private _buildQuery(queryData: CreateBuildQueryData, table: string, knex: any): any {
        const age = queryData.queryParam.persons[0].age;
        let columns = this._getColumns();
        knex = knex(table).column(columns)
            .count("plan_id as participants")
            .sum("annual_premium as total_annual_premium")
            .select()
            .whereRaw("age_minimum <= ? AND age_maximum >= ?", [age, age]);
        knex = this._updateCondition(queryData, knex);
        return knex.groupBy(this._getColumns());
    }

    private _updateCondition(queryData: CreateBuildQueryData, knex: any): any {
        const params = MakePlanCaseQueryParam(queryData.queryParam);

        if (params.planId) {
            knex = knex.where("plan_id", params.planId);
        } else {
            let conditions: any = {};
            if (params.countryOfResidence === params.nationality) {
                conditions["only_expat_insurance"] = false;
            }

            if (params.outpatientCover === "1") {
                conditions["outpatient_cover"] = true;
            }

            if (params.dentalCover === "1") {
                conditions["dental_cover"] = true;
            }

            if (params.maternityCover === "1") {
                conditions["maternity_cover"] = true;
            }

            if (params.opticalCover === "1") {
                conditions["optical_cover"] = true;
            }

            knex = knex.where(conditions)
                .andWhereRaw("excess <= ?", [params.excess])
                .andWhereRaw("maximum_cover >= ?", [params.maximumCover])
                .andWhere("master_areas_of_cover", "like", `%${params.masterAreaOfCover}%`)
                .andWhere("list_of_sub_zone_of_cover_countries_ids", "like", `%${params.countryOfResidence}%`)
                .andWhere("list_of_residence_plan_availability_country_ids", "like", `%${params.countryOfResidence}%`);
        }

        console.log(knex.toString(), "AT");

        knex = knex.orderBy(params.sortBy, params.sortOrder);
        knex = knex.limit(50).offset(0);
        return knex;
    }

    private _getColumns() {
        return [
            "plan_case_id",
            "plan_title",
            "plan_name",
            "plan_id",
            "company_name",
            "area_of_cover",
            "currency",
            "excess",
            "maximum_cover",
            "maximum_cover_periodicity",
            "excess_periodicity",
            "outpatient_cover_maximum",
            "outpatient_cover_periodicity",
            "outpatient_cover",
            "outpatient_cover_information",
            "dental_cover_maximum",
            "dental_cover_periodicity",
            "dental_cover",
            "dental_cover_information",
            "maternity_cover_maximum",
            "maternity_cover_periodicity",
            "maternity_cover",
            "maternity_cover_information",
            "optical_cover_maximum",
            "optical_cover_periodicity",
            "optical_cover",
            "optical_cover_information",
            "other_highlights",
            "logo_url",
            "benefits_schedule_pdf_url",
            "general_conditions_pdf_url",
            "application_form_pdf_url",
            "co_branding",
            "co_branding_link",
            "electronic_signature_application_link",
        ];
    }

}

export interface RawPlanCaseQueryParam {
    planId?: string;
    page?: number;
    sortBy?: string;
    sortOrder?: string;
    masterAreaOfCover?: string;
    countryOfResidence?: string;
    nationality?: string;
    maximumCover?: number;
    excess?: string;
    numberInsured?: string;
    outpatientCover?: string;
    maternityCover?: string;
    dentalCover?: string;
    opticalCover?: string;
    persons: Person[];
    limit?: number;
}

export interface Person {
    id?: string;
    age: string;
    gender?: string;
    nationality?: string;
    relationShip?: string;
    masterAreaOfCover?: string;
}

class PlanCaseQueryParamCreator {
    private planId: string;
    private page: number;
    private sortBy: string;
    private sortOrder: string;
    private masterAreaOfCover: string;
    private countryOfResidence: string;
    private nationality: string;
    private maximumCover: number;
    private excess: string;
    private numberInsured: string;
    private outpatientCover: string;
    private maternityCover: string;
    private dentalCover: string;
    private opticalCover: string;
    private limit: number;
    private persons: Person[];

    constructor(queryParam: RawPlanCaseQueryParam) {
        this.planId = queryParam.planId || null;
        this.page = queryParam.page || 1;
        this.sortBy = queryParam.sortBy || "total_annual_premium";
        this.sortOrder = this.sortBy === "always_asc" ? "desc" : "asc";
        this.masterAreaOfCover = ";" + queryParam.masterAreaOfCover + ";" || ";1;";
        this.countryOfResidence = ";" + queryParam.countryOfResidence + ";" || ";220;";
        this.numberInsured = queryParam.numberInsured || "1";
        this.outpatientCover = queryParam.outpatientCover || "0";
        this.maternityCover = queryParam.maternityCover || "0";
        this.dentalCover = queryParam.dentalCover || "0";
        this.opticalCover = queryParam.opticalCover || "0";
        this.limit = queryParam.limit || Configuration.constant.PLAN_LIST_ITEM;
        this.nationality = ";" + queryParam.nationality + ";" || ";220;";
        this.maximumCover = queryParam.maximumCover || 0;
        this.excess = queryParam.excess || "0";
        this.persons = queryParam.persons;
    }

    public create() {
        return {
            planId: this.planId,
            masterAreaOfCover: this.masterAreaOfCover,
            maternityCover: this.maternityCover,
            dentalCover: this.dentalCover,
            opticalCover: this.opticalCover,
            numberInsured: this.numberInsured,
            page: this.page,
            countryOfResidence: this.countryOfResidence,
            outpatientCover: this.outpatientCover,
            sortBy: this.sortBy,
            sortOrder: this.sortOrder,
            limit: this.limit,
            nationality: this.nationality,
            maximumCover: this.maximumCover,
            excess: this.excess,
            persons: this.persons,
        };
    }
}

function MakePlanCaseQueryParam(queryParam: RawPlanCaseQueryParam) {
    return new PlanCaseQueryParamCreator(queryParam).create();
}

interface CreateBuildQueryData {
    queryParam: RawPlanCaseQueryParam;
    count?: boolean;
    countAll?: boolean;
}
